## Midterm Study Guide

__Reminder: Midterm is 15 June!  We will also have a pair programming exercise that day.__

1. Be able to explain difference between software engineering, computer science, programming
2. Understand the Software Development Life Cycle (SDLC)
  1. Analysis
  2. Requirements
  3. Design
  4. Development
  5. Integration and Test
  6. Release
  7. Maintenance
  8. Optional steps - External Acceptance, Regulatory Checks, DevOps, EOL, Customer Support...
3. ^ Traditional waterfall method - what are the problems with this?
4. Who are the stakeholders in software development
5. Top-down vs Bottom-Up design; when would you use either?
6. The Iron Triangle of Project Management (Cost / Schedule / Scope & Quality)
7. Brooks's Law (Adding manpower to a late software project makes it later) 
8. Understand different development methodologies (benefits and drawbacks), esp:
  1. Cowboy coding
  2. Waterfall
  3. Iterative and Incremental
  4. Agile
9. Be able to explain Agile/Scrum
  1. What is a standup? 
  2. Sprint?
  3. User Story?
  4. Product backlog?
  5. Retrospective?
  6. Spike?
  7. Kanban board?
10. Test-Driven Development
  1. Understand unit tests
  2. Red-green-refactor loop
  3. What kinds of assertions to use?
    1. assertTrue
    2. assertEquals
    3. assertNull
    4. assertSame
11. External Quality vs Internal Quality
12. Object-Oriented Design
  1. Coupling (which is better, loose or tight?)
  2. Cohesion (which is better, high or low?)
13. Define Walking Skeleton
14. Object-Oriented Style:
  1. Encapsulation
  2. Information Hiding
  3. Postel's Principle
15. What is a leaky abstraction?  Is it good or bad?
16. Common Architecture Patterns
  1. Layered Architecture
  2. Model-View-Controller
  3. N-Tier
  4. Client-Server
  5. Blackboard
  6. Pipeline
  7. Event-Driven
  8. Microkernel
  9. Big Ball of Mud
17. Object-Oriented Analysis
  0. UML
    1. Class diagram
    2. Sequence Diagram
  1. DRY 
  1. SOLID Principles
    1. Single Responsibility Principle
    2. Open Close Principle
    3. Liskov Substitution Principle
    4. Interface Segregation Principle
    5. Dependency Inversion Principle
  2. Drawbacks from using SOLID Principles?
18. Design Patterns
  0. Utility pattern
  1. Singleton
  2. Factory
  3. Decorator
  4. Prototype
  5. Pool
    1. Thread
    2. Object
  6. Iterator
  7. Observer
  8. Null Object
  9. Flyweight
  10. Decorator
